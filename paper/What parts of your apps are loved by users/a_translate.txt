"アプリのどの部分がユーザーに愛されているのか？"

概要
最近、Begelらは、ソフトウェア開発者が尋ねる最も重要な質問の1つが、"ソフトウェアのどの部分がユーザーに使われ、愛されているか "であることを明らかにしました。ユーザーレビューは、この疑問を解決するための効果的な手段です。しかし、既存のレビュー要約ツールのほとんどは、レビューを単語の袋（すなわち、混合されたレビューカテゴリ）として扱い、ソフトウェアの側面とユーザーの好みを抽出することに限定されています。

我々は、新しいレビュー要約フレームワークであるSURMinerを発表する。SURMinerは、レビューを単語の袋として扱うのではなく、5つのカテゴリに分類し、パターンベースのパーサーを用いてアスペクトの評価を含む文章からアスペクトを抽出します。そして、SURMinerは2つのインタラクティブなダイアグラムを用いて要約を可視化します。17の人気アプリを対象とした評価では、SUR-Minerは既存の技術よりも正確で分かりやすいアスペクトを要約することができ、平均F1スコアは0.81で、ReviewSpotlight（0.56）やGuzmansの手法（0.55）を大幅に上回る結果となりました。また，開発者からのフィードバックによると，88%の開発者がSUR-Minerによるサマリーの有用性に同意しています．

I.イントロダクション

ソフトウェア開発者は，開発したソフトウェアのどの部分がユーザに利用されているかを知りたいと思うことがよくあります．Microsoft 社のエンジニア 4,000 名を対象とした調査によると， 「ソフトウェア製品のどの部分（アスペクト）が顧客に最も使われているか， あるいは愛されているか」という質問は，開発者が行う 145 の質問の中で第 2 位にランクされています [5]．この質問では，ソフトウェアのさまざまな側面に対する好みや意見を分析することが求められます．

ユーザーレビューは，ソフトウェア開発者がユーザーの要求，好み，不満を理解するための重要な手段である[21]，[31]．ユーザーレビューを分析することで，開発者は製品を評価したり，ユーザーの好みを特定したりすることができ[21]，ソフトウェアのメンテナンスや進化のタスクを改善することができます[33]．

しかし，ソフトウェアのレビューを理解することは，非常に困難で面倒な作業です．まず，ユーザーレビューの量が多すぎて，手作業でチェックすることができません．開発者は毎日、数百から数千のレビューを受け取ります [10]、[31]。大量のレビューがある場合，開発者はレビューを読んで，苦情や新機能の要求に手動で分類する必要があります [30]．このようなプロセスは、非常に時間がかかり、退屈なものです。一方、ユーザーレビューには、区別する必要があるほど多くの種類があります[31]。ユーザーレビューには，新機能の要求，バグレポート，賞賛，苦情などがあります．レビューの種類によって、対象となるタスクや開発者が異なります[30]。例えば，褒めているレビューは，ソフトウェアのテストには役に立たないかもしれませんが，製品の評価には不可欠です．また，バグを報告するレビューは，要求分析には重要ではないが，ソフトウェアテストには重要である場合がある．何百万ものレビューがある場合，開発者はまずそれらを手作業で分類しなければなりません [30]．

ソフトウェアユーザのレビューを要約するツールはいくつか提案されている．例えば，Chenら[10]は，情報量の少ないレビューを分類手法でフィルタリングし，Latent Dirichlet Allocation（LDA）[6]を用いて情報量の多いレビューのトピックを要約している．Fu et al. [15] は，回帰モデルを用いて，評価と異なる感情を持つ評価不一致のレビューをフィルタリングしています．また，LDAを用いて残りのレビューのトピックを要約し，トピックごとの評価の傾向を示している．Iacobら[21]は，新機能を要求するレビューを言語規則でフィルタリングし，要求のキーワードをLDAで要約している．これらのツールは、情報が豊富で信頼性の高いレビューを要約します。しかし、彼らが使用したLDAモデルは、文の構造や意味を考慮せず、bag-of-wordの仮定に基づいています。このような仮定は，複数の目的（例えば，側面の評価と機能の要求）と感情を示すソフトウェアレビューにとっては問題となる可能性がある．これらのツールでは，側面と意見が混在したり，異なるカテゴリに関連するトピックが混在したりするため，各側面に対するユーザの感情を測定するのに有効ではない．

このような問題を解決するために，我々は，ソフトウェアの各側面に対するユーザの感情や意見を要約するフレームワークであるSoftware User Review Miner (SUR-Miner)を提案する．SUR-Minerは、レビューを単語の集まりとして扱うのではなく、ソフトウェアユーザのレビューの単調な構造とセマンティクスを最大限に利用し、あらかじめ定義された文のパターンに基づいてレビュー文からアスペクトと意見のペアを直接解析します。次に、各レビュー文の感情を分析し、同じ文の中のアスペクトと意見のペアに感情を関連付けます。最後に、同じアスペクトを持つアスペクトと意見のペアをクラスタリングすることで、ソフトウェアのアスペクトを要約する。

SUR-Minerは、Swiftkey、Camera360、WeChat、Tempplerun2など17種類のAndroidアプリの最近のユーザーレビューを対象にして、SUR-Minerの性能を実証的に評価しました。SUR-Minerの性能は，分類，アスペクト・オピニオン抽出，感情分析の各プロセスにおいて，テキストマイニングの分野で一般的な精度指標であるF1スコアで評価しています[14], [38]．その結果，SUR-Miner は信頼性の高い要約を生成し，レビュー分類，アスペクト・オピニオン抽出，センチメント分析の平均 F1 スコアはそれぞれ 0.75，0.85，0.80 でした．SUR-Minerによる最終的なアスペクトは、F1スコアが0.81となり、ReviewSpotlight（0.56）やGuzmansの手法（0.55）を上回るなど、最先端の技術に比べて有意に精度が高く、わかりやすいものとなりました。

SUR-Minerのサマリーを用いて、アスペクトヒートマップとアスペクトトレンドマップという2つのインタラクティブな図を作成し、開発者がソフトウェアの各アスペクトに対するユーザの好みや典型的な意見を把握できるようにしました。対応するアプリ開発者からのフィードバックも励みになり、88%の回答者がSUR-Minerのサマリーが有用であると同意しており、SUR-Minerが実際に様々な側面に対するユーザの好みを開発者が理解するのに役立つことを示しています。

本研究では，以下のような貢献をしています．

1) バグレポートや新機能の要望などの5つのレビューカテゴリを区別するために，テキスト特徴量を設計した分類技術を活用した．

複雑なアプリレビュー文を解析し，アスペクトと対応する意見を抽出するパターンベースの解析技術を提案する．

3) アプリの開発者や管理者が効率的に要約を提示するために、新しいインタラクティブなビジュアライゼーションを設計する。

4) SUR-Minerの有用性を検証するために，実証的な評価を行う．

本論文の残りの部分は以下のように構成されている。セクションIIでは、関連する研究を紹介します。セクションIIIでは、我々のフレームワークの詳細設計を示す。セクションIVでは，評価を行う．セクションVでは、検証の脅威について議論し、セクションVIでは、論文を締めくくります。

II. 関連する仕事

A. アプリレビューフィルタリング

アプリレビューのフィルタリングは、ソフトウェア工学のコミュニティで注目を集めています。Chenら[10]は，非情報的なレビューをフィルタリングし，重要性によってユーザレビューをランク付けしています．彼らのフレームワークは、分類器を学習し、レビューを情報提供と非情報提供の2つのクラスに分類します。Fu et al. [15] は，レビューの語彙に関する回帰モデルによって，評価が一致しないレビュー（評価と異なる感情を持つレビュー）をフィルタリングしています．これらのツールは、部分的に有益なレビューを選択することができます。しかし、開発者によって必要とされるレビューの種類が異なるため、どのような状況でレビューが有益であるかを明確に定義していません[30]、[31]。彼らの研究のさらなるステップとして、我々は、異なるレビューの目的（カテゴリ）を区別し、特定のカテゴリからレビューを選択して、ソフトウェアの側面を抽出して要約することを目指しています。

Sorboら[13]による最近の研究では、開発メールをその目的に応じて分類するという同様のアイデアが提案されています。彼らはまた、自然言語解析技術を用いた分類アプローチを設計しています。彼らの技術はアプリレビューの分類にも適用できますが、各カテゴリ内でのアスペクトの要約はサポートしていません。

B. アプリレビューからのアスペクト抽出

アスペクト抽出は、ソフトウェア工学においても広く研究されている。Chenら[10]はLDA[6]を用いてレビューのトピックを抽出しています。Huら[19]は，Webレビューのマイニング手法を提案している．この手法では、頻出する単語をアスペクトとして抽出し、対応する形容詞の単語をオピニオンとしてリンクさせている。Fu [15] は，ユーザのネガティブなフィードバックをマイニングする問題に取り組んでいる．彼らは，LDAトピックモデルを用いて，ネガティブフィードバックからトピックを抽出し，リリースごとにまとめられた問題点をランク付けしている．Galvisら[16]は，Aspect and Sentiment Unification Model（ASUM）[22]というトピックモデルを適用することで，要件の変更をマイニングしています．また，共通のトピックを抽出し，それらのトピックに対するユーザの意見を提示している．

しかし，彼らのアプローチは我々のアプローチとは大きく異なる．彼らは、文章の構造や意味を考慮せず、バッグ・オブ・ワードの仮定に基づいて、頻出アイテムのマイニングやトピックモデルを適用しています。つまり、レビューのカテゴリー（賞賛、機能要求、バグ報告、欠点）や側面、ユーザーの意見を区別することができず、不正確で混乱を招く可能性があるのです。例えば、LDAによって抽出されたトピックワード「prediction」は、ユーザーが予測機能を評価していることを意味しているかもしれませんし、逆にユーザーが新しい予測機能を望んでいることを意味しているかもしれません。このような場合、開発者はトピックを効率的に解釈することができません。

Sarroらの最近の研究では、自然言語処理を用いてアプリの説明から特徴を抽出しています[34]。我々の研究は、アプリのレビューから特徴を抽出する点で彼らの研究とは異なる。また，我々はアプリの特徴を要約することを目的としていますが，彼らは特徴のライフサイクルを調査することを目的としています[34]．

我々の知る限りでは、我々の研究と密接に関連する先行研究は1つしかありません。Guzman and Maalej [17]は、ソフトウェアの特徴を抽出し、その感情を分析することを提案しました。我々の研究は、3つの主要な側面で彼らの研究とは異なります。まず、我々のアプローチは、特徴を特定するだけでなく、特徴の評価と特徴の要求を区別することを目的としている。第二に、彼らの手法が従来の手法のように頻出項目のマイニングやトピックモデルに基づいているのに対し、我々の手法は意味的パターンを用いてレビュー文を解析するため、複雑で新しい特徴を識別することができる。最後に、アプリ管理者や開発者が機能評価や感情の傾向を把握するのに役立つ、インタラクティブなビジュアライゼーションを提案します。

C. 他のマーケットプレイスにおけるレビューマイニング

ユーザーレビューのマイニングは、他のマーケットプレイス（例：商品、映画）においても魅力的なトピックです。Yataniら[37]はReviewSpotlightと呼ばれるレビュー要約ツールを提案した。このツールは、レビュー文から形容詞と名詞の単語ペアを識別することで、アスペクトとオピニオンのペアを抽出する。Huangら[20]は同様のアイデアを採用し、レストランのレビューを要約するための抽出型インターフェースであるRevminerを設計した。Nicholsら[29]は、レビュー文をNLP技術で解析するReCloudを提案した。Zhuangら[38]は、映画のレビューの要約を研究した。彼らのアプローチは、WordNet、統計分析、映画の知識を含む複数の知識を統合する。

しかし，これらの技術をアプリのレビューに直接適用することは困難です．アプリのレビューは、他のマーケットプレイスでのレビューとは全く異なります[10]、[15]。アプリのレビューは、他のマーケットプレイスのレビューとは全く異なります[10]、[15]。既存のツールではほとんど解析できない、異なる語彙やフォーマットを持っています。ReviewSpotlight [37]は、形容詞と名詞の単語ペアを抽出してワードクラウドを表示します。同様に、RevMiner [20]は、ブートストラップアルゴリズムを使用して単語ペアを抽出します。ReCloud [29]はセマンティックを考慮し、ワードクラウドを提示しますが、NLPのコンテキストを反映した空間的なレイアウトになっています。しかし、アプリのレビューは、単にワードクラウドやワードペアでは表現できません。例えば

case 1: "テーマを変えられるところが気に入っています"

形容詞がないのでReviewSpotlightは何も出力できません。RevMinerやReCloudは、意味のない単語ペアを提示する可能性があります。これに対し、SUR-Minerは、意味論やアプリレビューのパターンを考慮しているため、正しいペア<テーマを変えられる、好き>を提示することができます。また、アプリレビューには、異なる開発者を対象とした複数の目的が含まれています[31]。既存のツールでは、このようなカテゴリーを区別することはできません。以下のケースを考えてみましょう。

ケース2："OK "ボタンをクリックした後のブルースクリーンが気になる" ケース3："シンプルなUIの方がいい"

開発者から見れば、これらは単なるバグレポートや機能要求であり、「画面」や「UI」に対するユーザーの意見とは考えられません。このようなケースは、アプリのレビューで大きな割合を占めています[31]。これらのツールでは、<button, annoying>や<U I, simple>などの単語ペア（クラウド）が出力されますが、SUR-Minerは分類技術を利用しているため、上記のケースを区別することができます。

III.SUR-MINER

本節では、SUR-Miner の一般的なアーキテクチャを紹介します。

図1に示すように、我々のフレームワークは、テキストや評価を含むユーザーレビューを入力とし、アプリのさまざまな側面に対する主な意見や感情を出力します。全体の手順は、6つの主要なステップで構成されています。要約する必要のある生のレビューについては、まず文章に分割します（ステップ1）。次に、各文章を5つのカテゴリー、すなわち、側面評価、賞賛、機能要求、バグ報告、その他に分類します（ステップ2）。そして、アスペクト評価のカテゴリーに属する文のみを選択し、他の種類の文をフィルタリングします。そして、「アスペクト評価」の文の集合から、アスペクトとそれに対応する意見や感情を抽出する（ステップ3-4）。結果として得られたアスペクト、意見、感情のペアをクラスター化し、2つのインタラクティブなダイアグラムで可視化します（ステップ56）。以下、各ステップについて詳しく説明します。

A. ステップ1 - 前処理

生のユーザーレビューは、前処理が必要です。生のレビューは、異なる目的を持った複数の文章で構成されていることが多いです。例えば、「The UI is ugly. I want a beautiful UI" は2つの文で構成されています。1つ目の文はアスペクトのUIに対する評価で、2つ目の文はアスペクトのUIの改善を求める内容です。両者は目的も心情も異なります。そのため、これらの文章を分離して分析することが望ましいです。また、ユーザーレビューには誤字・脱字が多く、自動的に意味を理解することが困難です。

これら2つの問題を解決するために，Stanford CoreNLPツール[26]を用いて，生のレビューテキストを文に分割しました．各レビュー文にはタイムスタンプが押され，生のレビューと同じように評価が割り当てられます．また，"U→you"，"coz→because"，"&→and"，"Plz→Please"，"sooo→so"，"thx→thanks "などの一般的な誤字や短縮形，繰り返しを修正しました．このようなタイポや短縮形を60個集めて、正規表現2で置き換えました。

B. ステップ2 - レビューの分類

セクションIで議論したように，レビュー文には異なるカテゴリが存在する可能性がある[31]．異なるカテゴリは，異なるタスクや開発者を対象としている[30]．開発者が手動でレビューを分類し、アスペクト評価のために適切な文章を選択することは、非常に面倒で時間がかかります。レビュー分類ステップでは、アスペクト評価を含むレビュー文を自動的に分類し、選択することを目的としています。

ここでは、アスペクト評価、バグレポート、機能要求、賞賛などの5つのレビューカテゴリを定義します。Paganoらは、ユーザーレビューの17のカテゴリ（トピック）を発見している[31]。我々は、彼らの分類法[31]から上位4つのカテゴリを使用し、その他のマイナーなカテゴリを「その他」カテゴリに統合する。表Iは、各カテゴリの定義とレビュー文のサンプルを示している。

レビュー文を上記のカテゴリーに分類するために，我々は教師付き機械学習のアプローチを採用した．まず，過去のレビュー文を収集し，そのテキスト特徴を抽出し，表Iの定義に従って手動でラベル付けを行う．そして，これらのテキスト特徴量とラベルを用いて分類器を学習します．最後に，この分類器を新しいレビュー文に対して実行し，そのカテゴリを予測します．

分類器には，テキストの分類に優れた性能を発揮するMax Entropyを採用しています[24], [28]．以下では，我々が分類のために設計したテキスト特徴を紹介する．

1) テキスト特徴の抽出。テキストの特徴として，語彙特徴と構造特徴の2つの次元を抽出した．

例えば，"amazing "と "baseball "のように，"amazing "と "baseball "では，語彙が大きく異なります。例えば、"amazing "や "great "は賞賛のレビューに頻繁に現れますが、"bug "や "fix "はバグレポートの代表的な単語です。ここでは、異なるカテゴリの語彙を反映していることから、文字Nグラムと幹単語を2つの語彙の特徴として選択しました。

文字Nグラム
重要な語彙表現である文字Nグラムは、テキスト分類でよく使われる特徴です[8], [9], [18], [23], [25]。また，ソフトウェア工学における悪意のあるコードの検出[4]や，重複したバグレポートの検出[36]など，多くのアプリケーションで有効であることがわかっている．ある文の文字Nグラム特徴量は，その文のトークンに含まれる連続したn個のすべての文字である．例えば、"The UI is OK "という文に対する3-Gramは、The, heU, eUI, UIi, Iis, isO, sOKとなる。私たちは2-4 Gramsを使って分類しています。

トランクワード 我々はまた、語彙の特徴としてトランクワードを提案する。我々は、幹となる単語を、後に紹介する意味依存グラフ[12]のルートにある単語と定義する。例えば，"The graphics are amazing" という文の幹となる単語は "are" である．

文章構造は、異なるレビューカテゴリが異なるシンタックスとセマンティクスを持つ可能性があるため、テキストの特徴を反映することもできます。例えば、アスペクト評価では、ユーザーは「The graphic (noun) is amazing (adjective)」のような記述的な構文を使う傾向がありますが、機能要求では、ユーザーは「please add more themes」や「It could be better to have more themes (noun)」のような命令的な文章を使うことが多いです。

私たちは、3つの構造的特徴を活用しています。POSタグ、構文解析ツリー、セマンティックディペンデンスグラフです。

POSタグ
Part Of Speech (POS) [11]は、テキストの文法的特徴として広く使われています。これは，文中の各単語の特性を示すものです．例えば，"The user interface is beautiful "という文のPOSタグは，DT-NN-NN-VBZ-JJの順になっています[11]．ここで，isという単語のPOSタグはVBZであり，isは3人称現在単数の動詞であることを意味している．POSタグは，Stanford CoreNLPツール[3]，[26]を用いて生成し，すべてのPOSタグを連結してテキスト特徴量としています．

構文解析ツリー
構文解析ツリーとは，文の文法構造を表す代表的なものである[35]．文章がどのように構成されているかを示しています．各ノードは文法ユニットを表し，その子はそのノードを構成するサブユニットです．図2は，Stanford Parser [3]によって生成されたレビュー文「The user interface is not very elegant」の構文解析ツリーを示したものです．各ノードのラベルは，POSタグを示しています．このツリーは，文（ルート）が名詞句（NP）とサブセンテンス（S）によって構成され，名詞句が限定詞（DT）と2つの名詞（NN）によって構成されていることを意味しています．

解析木をフラットなテキスト特徴として表現するために、木のノードをbreadth first orderでトラバースし、最初の5つのノードを選択します。そして，この5つのノードのPOSタグを連結して，テキスト特徴量とします．例えば、図2の解析木の特徴量は「ROOT-NP-S-DT-NN-NN」となります。SDG（Semantic Dependence Graph） SDG（Semantic Dependence Graph）[12]は，1つの文に含まれる単語間の意味的な依存関係を示す．これは有向グラフである[12]。グラフのノードは，単語と，それに対応する POS タグを表す．辺は、単語間の意味的な関係を表します (たとえば、名詞の主語と形容詞の修飾語)。各SDGには、入力エッジを持たないルートノードがあります。図 3 は、Stanford Parser [3] によって生成されたレビュー文のサンプル「The user interface is not elegant」の SDG を示しています。ルートノードは、形容詞である elegant という単語です (JJ と表記)。このノードには，名詞主語（nsubj）のinterface，コピュラ（cop）のis，否定修飾語（neg）のnotという3つの子があります．また、子インターフェイスには、決定詞 (det) the および名詞複合修飾子 (nn) user という 2 つの子があります。


SDG をフラットなテキストフィーチャに変換するには、そのノードを幅優先でトラバースし、トラバース中のエッジと POS タグを連結します。ルートにリンクされていないリーフは無視する。たとえば、図 3 の SDG の特徴は、「VBZ-nsubj-NN-cop-VBZ-neg-RB」である。

C. ステップ3 - アスペクト・オピニオンの抽出

我々の次の目標は、対応するアスペクトに対するユーザーの意見を要約することです。そのためには、アスペクトを表す単語と、そのアスペクトに対する意見を表す単語を特定する必要があります。このステップでは、SUR-Minerは、アスペクト評価カテゴリに分類された各レビュー文から、アスペクト-オピニオンのペア（アスペクトとオピニオンの単語）を抽出します。例えば、「The Prediction is accurate, but the auto-correct is annoying」というレビュー文に対するアスペクトとオピニオンのペアは次のようになります。<prediction, accuracy>と<auto-correct, annoying>です。

一般的に、最新の技術では、頻出項目のマイニングや、ユーザーレビューを単語の袋と見なすトピックモデルによってアスペクトを抽出しています[6], [10], [15]。このような仮定は，複数の目的や感情を持つソフトウェアレビューにとっては問題となる可能性があります．

経験的な研究が示すように、ソフトウェア・レビューは、目的が異なるとかなり単調なパターンになる[31]。そのため，文のパターンからアスペクトとオピニオンのペアを直接決定することが可能である．この仮定に基づいて、レビュー文の構文と意味を利用し、アスペクトとそれに対応する意見を直接解析するパターンベースの解析方法を設計します。そのために、まず、NLPパーサーを使用して、レビュー文の意味依存グラフ（SDG）[12]をアノテーションします。次に、パターンベースのパーサーを構築し、SDGからアスペクトとオピニオンのペアを抽出します。

1) パターンベースのパーシング。このパターンベースのパーサーは、カスケード接続された有限状態機械のシーケンスとして実装されています[7]。パーサーはSDGを受け取り、定義済みの意味的テンプレートに基づいてアスペクトとオピニオンのペアを識別します。

表 II に、使用する典型的な意味的テンプレートを示します。冒頭の 2 文字 (例: JJ および NN) は、ルートの POS タグを表しています。次の丸括弧内の単語（例えば，haveとlike）は，ルートの単語を表します。ルートの子は，角括弧内にエッジ-POSペアとして記載されている。例えば，1行目のテンプレートは，JJというPOSタグを持つルートノードと，NNというPOSタグを持つ名詞主語（nsubj）とVBZというPOSタグを持つコピュラ（cop）という2つの子を意味しています。このテンプレートは，レビュー文からアスペクト部と意見部を手作業で抽出して作成したものである。アスペクト評価とラベル付けされたレビュー文の中から、後に精度評価に使用するものを除いた2,000のレビュー文をランダムに選んだ。まず、これらの文章をすべて調べて、SDGを生成しました。そして、各SDGを、SDG内のアスペクト部分とオピニオン部分の位置を示すテンプレートと関連付けました。偶然の関連付けを避けるために、10以上の文に関連するテンプレートをすべて選択しました。このようにして26個のテンプレートを特定し、有限状態機械3を設計しました。

パーサーは、新しいSDGインスタンスが与えられると、ルートから他のすべてのノードに移動し、ノード、エッジ、および対応する子をチェックして、テンプレートに従ってアスペクトおよびオピニオンワードを決定します。たとえば、図 3 の SDG の場合、パーサーはルートの POS タグをチェックします。これは形容詞 (JJ) であり、表 II の 1 番目と 2 番目のテンプレートに一致するため、さらに、名詞 (NN) の POS タグを持つ名詞主語 (nsubj) 、VBZ の POS タグを持つコピュラ (cop) 、および RB の POS タグを持つ否定修飾語 (neg) の 3 つの子を持つかどうかをチェックします。2つ目のテンプレートがマッチします。そして、最初の子に、POSタグがnoun(NN)の名詞複合修飾語(nn)の子があるかどうかをチェックします。2 番目のテンプレートはサンプル SDG と絶対的に一致しているので、パーサーは nsubj-NN ノードのインターフェイスとその子のユーザーをアスペクトワードとして認識し、neg-RB ノードはルートノードの elegant と一緒になっていないので、オピニオンワードとして認識します。

D. ステップ 4 - アスペクトセンチメント分析

ユーザーの好みを把握するには、意見だけでなく、各側面に対するユーザーの感じ方を定量的にまとめることも有効です。ユーザーの評価は、そのような要約を客観的に提供することができます。しかし、総合的な評価では、異なる側面に対するユーザーの好みを十分に表現することはできません。例えば、「The UI is nice but the sound sucks.」という評価2（5点満点）のレビューを考えてみましょう。このユーザーは、明らかにUIは気に入っていますが、音は気に入っていません。したがって、両方の側面に対する実際の評価は2ではなく、UIが3、音が1となる可能性があります。

第4のステップでは、各レビュー文にセンチメント分析を適用し、ユーザーの評価とセンチメント分析ツールを用いて、センチメントを対応するアスペクトに関連付けます。まず、最先端のセンチメント分析ツールであるDeeply Moving [1]を適用して、各レビュー文のセンチメントを分析します。Deeply Movingは、0から4のスケールでセンチメントを生成します。4は強くポジティブ、0は強くネガティブ、2はニュートラルを表します。そして、精度を高めるために、ユーザーの評価（1〜5）によってセンチメントを調整します。具体的には、レビュー全体の評価が5（強く肯定的）であれば、0の感情に1を加え、評価が1（強く否定的）であれば、4の感情に1をマイナスしています。

例えば、以下のレビューには2つの文章があります。インターフェースは美しい。I don't like the theme. この2つの文章の感情は、それぞれ4と0です。レビューのユーザー評価が5の場合、2つ目の文章の感情を1（＝0+1）に調整します。ユーザー評価が1であれば、1文目のセンチメントを3（＝4-1）に調整します。

E. ステップ5 - アスペクトのクラスタリングとサマライズ

このステップでは、同じアスペクトを持つアスペクトと意見のペアをグループ化し、各アスペクトグループのセンチメントと典型的な意見を要約します。

アスペクトをグループ化するために、まず、すべてのアスペクト語の頻出項目、すなわち、抽出されたアスペクト-オピニオン・ペアのアスペクト語を抽出します。そして、アスペクトと意見のペアを、共通の頻出項目（単語）でクラスタリングします。例えば、オートコレクトがすべてのアスペクト語の頻出項目であるとすると、この項目を含む2つのアスペクト-オピニオンのペアがあれば、それらのペアは1つのグループにクラスタリングされます。特に、2つ以上の異なるグループにクラスタリングできる頻出項目がある場合は、項目や単語の頻度が最も高いグループにクラスタリングします。例えば、<background color, nice>というペアは、<background, beautiful>と<color, disgusting>の両方とグループ化することができる。しかし、背景という側面が色という側面よりも高い頻度を持つことが既に分かっている場合、最初のペアを3番目のペアではなく2番目のペアとグループ化する。2つのアスペクト-オピニオンのペアに頻出項目がない場合、アスペクトに共通の単語があるときは、それらをグループ化します。

各グループにおいて、そのグループ内で最も頻度の高い単語やアイテムをグループキーワードとして選択します。また、グループ内のアスペクトとオピニオンのペアの平均調整センチメントとして、グループセンチメントを計算します。

F. ステップ6 - 視覚化

サマリーを説明するために、「アスペクト・ヒートマップ」と「アスペクト・トレンドマップ」という2つのインタラクティブな図を作成しました。

アスペクト・ヒートマップは、ユーザーが関心を寄せる人気の高いアスペクトを示しています。これは、開発者や管理者が、アプリのどの部分（アスペクト）がユーザーに愛されているのか、あるいは嫌われているのかを把握するのに役立つことを目的としています。図4は、アスペクト・ヒートマップの例で、それぞれの円がアスペクトを示しています。円が大きければ大きいほど、そのアスペクトは人気があり、好まれていることを意味します。ここでは、円の大きさを size = log(#comments) + sentiment と定義しています。横軸はコメント数、縦軸は調整後の評価を表しています。したがって、右上の円は最も人気のあるアスペクトと愛されているアスペクトを表し、その逆もまた然りです。アスペクトグループを把握するために、開発者は各アスペクト（円）をクリックして、ポジティブな感情とネガティブな感情の上位にある特定のコメントを見ることができます。各コメントには、アスペクトを表す単語に下線が引かれ、意見を表す単語は太字で表示されます。

アスペクト・トレンド・マップは、時系列でのセンチメント・トレンドを示しています。ユーザーの反応を捉えることは，開発者が機能を選択し，優先順位をつけるために重要である[16]，[34]．アスペクト・トレンド・マップは，開発者が最近行った変更がユーザの満足度に影響を与えたかどうかを評価するのに役立つことを目的としています．また，開発者はユーザーの好みを推定・予測することで，将来的に製品の一部を改善することができます．図5はその例であり、各線は人気のあるアスペクトに対する感情の傾向を示している。横軸は日付、縦軸はユーザーの感情を表しています。

アスペクト・ヒートマップとアスペクト・トレンドマップは、いずれもプロジェクトのウェブサイトで公開されています。
http://www.cse.ust.hk/∼xguaa/srminer/.

4.実証的評価

我々のフレームワークを、有効性、比較、有用性の3つの側面から評価する。有効性と優位性を評価するために、テキストマイニングの文献にある一般的な尺度を適用し、その結果を最先端の手法と比較する。また、有用性を評価するために、開発者アンケートを実施しています。具体的には，以下のような研究課題を設定して評価を行っている。

RQ1（有効性）：SUR-Minerは、アプリのレビューの分類、側面や意見の抽出、感情の分析をどれだけ効果的に行えるか？

RQ2（比較）：SUR-Miner は、アプリレビュー要約の最新技術と比較してどうか？

RQ3（有用性）：SUR-Minerによる要約は、開発者にとってどの程度有用か？

A. データ収集

Google PlayからSwiftkey、Camera360、WeChat、Tempplerun2など、人気の高いAndroidアプリ17本を題材として選びました。これらのアプリは、ゲーム、コミュニケーション、書籍、音楽など、最も人気のある16のカテゴリーをカバーしています。オープンソースのAndroid market API [2]を用いて，2014年8月から2015年3月の間に，おおよそのレビューを収集しました。各レビューについて，タイムスタンプ，評価，タイトル，内容を収集しています．表IIIに，対象者の説明を示します。

B. 効果 (RQ1)

本節では，SUR-Minerの有効性について，レビュー分類，アスペクト・オピニオン抽出，感情分析の各ステップにおける評価を示す．

1) レビューの分類 まず、SUR-Minerをレビュー分類タスクで評価します。各データセットから2,000件のレビュー文をサンプリングし、その予測結果をゴールデンスタンダードラベルと比較しました。ゴールデンスタンダードクラスのラベル付けは、表Iのルールに従って手動で行いました。ラベル付けの偏りを減らすため，2人の研究者が別々に2,000のレビュー文にラベル付け規則を適用した．最初の繰り返しでは、コンセンサスラベルが選択された。不一致の場合は、ラベル付けのルールを議論して明確にし、再度ラベル付けを行った。2回目のイテレーションでは、2人の研究者の間で100％の合意が得られた。

分類精度の測定には，F1スコアを用いた．F1スコアは，テキスト分類の文献で広く用いられている[16], [38]．F1スコアは次のように定義される．

<math>

ここで，精度は，あるクラスに正しく分類されたインスタンスの数（TP）と，そのクラスに分類されたインスタンスの数（TP+FP）の比である．

リコールは、クラスに正しく分類されたインスタンスの数(TP)と、クラスに分類されたインスタンスの数(TP+FN)の比である。

<math>

各フォルダに400件のレビュー文が入っている状態で，データセットで5倍のクロスバリデーション[38]を100回行った。

表4は，異なるカテゴリー4のF1スコアを示している．各列は，すべての被験者におけるレビューカテゴリのF1スコアを示している．最後の列は，各被験者の結果をすべてのレビューカテゴリで平均化し，最後の行は，各レビューカテゴリのF1スコアをすべての被験者で平均化したものである。表に示されているように、分類性能は、アスペクト評価カテゴリ（平均F1スコアは0.74）と同様に、妥当なものである。これは、分類ステップが、異なる開発者に異なるレビュー文を正確に提供できることを意味しています。また、アスペクト評価では、信頼性の高いレビュー文を提供しています。バグ」などの特定のカテゴリのF1スコアは、一部のアプリでは良くありません。これらのレビューを手動で確認したところ、これらのアプリにはまれにしかバグ報告がないことがわかりました。データが極端に偏っていたことが、これらの異常値の主な原因と考えられます。

2) アスペクト・オピニオンの抽出 SUR-Minerのアスペクト・オピニオン抽出性能を評価するために、レビュー分類実験と同様の手順で、SUR-Minerがレビュー文からアスペクトとそれに対応するオピニオンを正しく抽出するかどうかを確認しました。各被験者について、2,000個のレビュー文をサンプリングし、Aspect Evaluationカテゴリに属するものを選択した。F1スコアを用いて、アスペクト抽出と意見抽出の精度を別々に測定しました。具体的には，式13の真陽性数(TP)は正しく抽出されたアスペクトや意見の数，偽陽性数(FP)は誤って抽出されたアスペクトや意見の数，偽陰性数(FN)は抽出されなかったアスペクトや意見の数と定義した．

その結果を表Vの最初の2列に示す。

示されているように、アスペクト抽出とオピニオン抽出はどちらも妥当な精度を持ち、平均F1スコアはそれぞれ0.85と0.84でした4。この結果は、アスペクト抽出ステップが信頼できるアスペクトとオピニオンを提供していることを示唆しています。

3) センチメント分析 センチメント分析の評価も、分類やアスペクト抽出と同様の手順で行いました。各被験者について、2,000のレビュー文をサンプリングし、アスペクト評価のカテゴリーに属するものを選択し、各アスペクトと意見のペアのセンチメントを黄金の標準センチメントラベルと比較しました。推定を容易にするために，我々はセンチメント・スケール（04）をポジティブ（3-4）とネガティブ（01）の2つの極性に分け，その極性に応じてラベル付けを行った[32]．ゴールデンスタンダードセンティメントのラベル付けは，レビュー分類のときと同様に手動で行った．

F1スコアを用いて，各センチメントカテゴリの精度を測定した．具体的には，式1-3の真陽性（TP）の数は，正しく分類されたセンチメントの数を意味し，偽陽性（FP）の数は，誤って分類されたセンチメントの数を意味し，偽陰性（FN）の数は，そのカテゴリに分類されなかったセンチメントの数を意味する．

その結果は，表Vの最後の2列に示されている．示されているように，ポジティブなセンテンスとネガティブなセンテンスの両方が許容できる精度を持ち，平均F1スコアはそれぞれ0.85と0.75であった4．また，両者の平均F1スコアは0.80である．Camera360とDuolingoで否定的な感情のパフォーマンスが相対的に低いのは、この2つのアプリには肯定的なレビューが多く寄せられ、感情のカテゴリが極端に偏ってしまったためと考えられる。この結果は、感情分析のステップが信頼できる結果をもたらすことを示唆しています。

SUR-Minerは、レビュー分類、アスペクト・オピニオン抽出、センチメント分析において、平均F1スコアがそれぞれ0.75、0.85、0.80と、信頼性の高い結果を提供しています。

C. 比較 (RQ2)

次の評価では、SUR-Minerと最新の技術を最終的なサマリーに関して比較することを目的とします。

1) 定量的な比較 まず、SUR-Miner のアスペクト抽出の精度を、関連する研究結果と比較します。ReviewSpotlight [37]とGuzmanの手法[17]と比較します。ReviewSpotlightは名詞と形容詞のペアを識別して一般製品のレビューを要約するツールであり（セクションII-C）、Guzmansのツールはアプリのユーザーレビューからもアスペクトを抽出する我々の最も関連性の高い研究である（セクションII-B）。

我々は、実世界の使用シナリオをシミュレートしてアスペクト抽出を実行します。各被験者に対して、元のデータセットから分類器の学習用を除いた全てのカテゴリのレビュー文400個をランダムに選択する。まず、これらの文章に対してレビューの分類を行う。次に、アスペクト評価として分類された文章に対して、アスペクト抽出を行う。抽出されたアスペクトを、手動でラベル付けされた標準的なアスペクトと比較します。セクションIV-B2と同じ定義を用いて，F1スコアを用いて精度を評価する．

表VIは，全被験者における3つのアプローチの平均F1スコアを示している．ReviewSpotlightを再現し，アプリのアスペクトを抽出するために適用した．Guzmansのアプローチの結果は、彼らの論文[17]から抜粋したものです。SUR-MinerのF1スコアは0.81で、ReviewSpotlight(0.56)やGuzmanのツール(0.55)を大きく上回っていることが分かります。

これらの結果の理由を調べるために、ReviewSpotlightの結果を手動で確認しました。その結果、レビューのカテゴリを区別せずに、アスペクトリクエストやバグレポートなど、他のカテゴリのレビューのアスペクトを抽出する傾向があることがわかりました。例えば、新しいアスペクトであるオフライン辞書を要求する「オフライン辞書が使えないのは嫌だ」というレビューを考えてみましょう。ReviewSpotlight は <dictionary, offline> という無意味な出力をしますが、SUR-Miner は存在しないアスペクトについて述べているため、このようなレビューをアスペクト評価から除外することができます。

また、これらの関連アプローチの欠点は、単純に頻出項目や名詞-形容詞のペアをアスペクトとみなしているため、複雑なフレーズを識別できないことです。例えば、"Also, love the way it auto ads reminders" というレビューに対して、ReviewSpotlight は単純に <ads, auto> を出力しますが、SUR-Miner は <the way it auto ads reminers, love> を出力します。

また、分類段階と抽出段階の両方にミスがあっても、それらを組み合わせても精度が悪くならないという点も興味深いです。分類ステップのF1スコアは0.74。アスペクト抽出ステップのF1スコアは0.85です（セクションIV-B）。しかし、分類段階の出力からアスペクトを抽出した場合、最終的なF1スコアは0.81となり、分類段階よりもさらに大きくなる。抽出されたアスペクトを手動で確認したところ、分類段階で誤って分類されたレビューがあったとしても、アスペクト抽出段階で「再修正」できることがわかりました。例えば、誤分類されたレビュー「公共交通機関のナビがない！」を考えてみましょう。このレビューは新しいアスペクトを必要としますが、分類段階ではAspect Evaluationに誤分類されていました。しかし、このレビューを解析する意味論的パターンがないため、SUR-Minerは依然としてどのアスペクトも認識できません。

2) 定性比較。LDA のようなトピックモデルは、最新のアプリレビュー要約ツールで広く使用されています [10], [15], [17]。これらのトピックベースの手法に対するSURMinerの優位性を調べるために、SUR-Minerによって抽出されたアスペクトとトピックモデルによって抽出されたトピックを定性的に比較します。

表VIIIは，Swiftkeyの被験者において，我々が抽出した上位5つのアスペクトと，AR-Miner（EMNB-LDAトピックモデルを適用した最先端のレビュー要約ツール）[10]による上位5つのトピックを比較したものである．我々は，AR-Minerと同じ期間のデータをGoogle Playから収集した．2つの観察結果があります。1) SUR-Minerは，異なるレビュー目的を区別することができる．例えば、SUR-Minerで抽出された意見は、ノイズを除いたアスペクト評価であるのに対し、LDA（ARMiner）で抽出されたトップワードは雑多なものです。例えば、アスペクト予測に対するユーザの評価を知りたい場合、AR-Miner (LDA)では提供できないが、SUR-Minerではexcellent, accurate, hateなどのユーザの意見を提供できる。例えば，管理者や開発者は，SUR-Miner では肯定的な感情と否定的な感情の両方を見つけることができますが，LDA ではユーザがそのアスペクト予測を好きなのか嫌いなのかを知ることができません。

全体として、SUR-Miner は LDA モデルと比較して、レビューの目的や感情を区別して、より明確なサマリを生成します。

SUR-Minerは最先端の手法よりもはるかに正確で明確な要約を生成します。

D. 有用性 (RQ3)

有用性の評価は主観的になる可能性があるため、SUR-Minerの有用性を評価するために開発者に相談しました。SUR-Minerは，Swiftkey，Camera360，WeChat，Tempplerun2など17種類の人気Androidアプリの最新ユーザレビューに適用した．可視化されたサマリーをデモとしてウェブサイトに掲載し，表VIIに示す質問を開発者に投げかけました．2つの質問は，それぞれ2つの図に関連しています．それぞれの質問に対して，5つの選択肢を用意した（強く同意する5，同意する4，どちらでもない3，同意しない2，強く同意しない1）。また、各質問に対して、各選択肢の数も記載しました。

選択したアプリの開発者に招待メールを送り，Google+ の Android 開発者コミュニティに当社の Web サイトを掲載したほか，Samsung，Tencent，Baidu などの IT 企業の開発者を招待してフィードバックを求めました。

その結果，開発者は我々のSUR-Minerに大きな関心を示した．表 VII に示すように，32 件の回答のうち，28 件 (88%) が当社のツールが開発者の役に立つことに同意しています．保守的な意見を持っていたのは2名（6.3%），反対意見を持っていたのは2名（6.3%）でした．図6は，開発者からのフィードバックのボックスプロット統計を示している．

1から5までの評価に対する回答を量子化しています。各ボックスは、1つの質問に対する回答を示しています。この結果が示すように、いずれの質問に対する回答も、平均評価が3を大きく上回っています。これは、SUR-Minerの有用性に開発者が同意していることを意味しています。

また、開発者からは以下のような励ましのコメントをいただきました。

"これは素晴らしいプロジェクトです。ビジュアライゼーションデータには感動しました！"

"可能であれば、この研究者と一緒に仕事をしたいと思います。センチメント分類器の性能がとてもいいですね。"

"提供されたビジュアライズされた情報は、製品の長所と短所を含む洞察を得るための非常に明確な手段となっています。大規模なユーザーのコメントを分析するには、人間の努力が必要です。このようなプロジェクトは、製品の理解と反復を迅速に行うことができます」。

これらのコメントは、ユーザーの意見を様々な角度から把握することができるSUR-Minerを開発者が高く評価していることを示しています。

このように，SUR-Miner はユーザの意見や感情の把握に役立っていることが，開発者からのフィードバックによって明らかになりました．

V.有効性を脅かすもの

妥当性を脅かすものとして、以下のものが挙げられます。

対象はすべて無料のAndroidアプリ。
本論文で調査したプロジェクトはすべて無料のAndroidアプリです。そのため、有料アプリや他の市場（AppStoreなど）のアプリを代表していない可能性があります[27]。また、商用アプリの場合、レビューパターンが異なる可能性があります。将来的には、商用アプリや他の市場のアプリのユーザーレビューを調査することで、この脅威を軽減していきます。

グラウンドトゥルースラベルは2人で判定しました。
ゴールデンスタンダードラベルは、人の手がかかるため、今回の実験では2人しか判定していません。そのため、実際のアプリ開発者から偏った評価を受ける可能性があります。この脅威を軽減するために、私たちは最終結果を開発者に提示し、その精度に満足していることを確認しました。将来的には、より多くの開発者をラベリングに招待することで、この脅威をさらに軽減していきます。

VI. おわりに

本研究では，効率的かつ自動的にユーザーレビューを要約するSUR-Minerを提案した．SUR-Minerによる要約は、開発者にとって「アプリのどの部分がユーザーに愛されているのか」という重要な問いに対する望ましい答えを提供する。

評価の結果、SUR-Minerは、レビュー分類、アスペクト・意見抽出、感情分析において、それぞれ平均F1スコア0.75、0.85、0.80と、信頼性の高い結果を得ることができました。SURMinerによる最終的なアスペクトは、F1スコアが0.81となり、ReviewSpotlight（0.56）やGuzmansの手法（0.55）を上回るなど、最新の技術に比べて格段に精度が高く、明確な結果が得られました。また、アプリ開発者からのフィードバックも非常に有望で、開発者からの回答の88％がSUR-Minerの有用性に同意しているとのことです。

今後は、機能要望などの他のレビューカテゴリについてもまとめていく予定です。また、コードコメントやバグレポートなど、他のソフトウェアのテキストデータを要約する技術も提案していきます。